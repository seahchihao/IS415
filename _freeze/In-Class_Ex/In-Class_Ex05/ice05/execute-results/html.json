{
  "hash": "d6cd3a901fd963b6e2862d07b445470e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In-Class Exercise 05\"\nauthor: \"Seah Chi Hao\"\ndate: 2024-09-16\ndate-modified: \"last-modified\"\nexecute:\n  eval: true\n  echo: true\n  freeze: true\n  output: true\n  warning: false\n---\n\n\n## 1.0 Installing R package (GWmodel)\n\nOn R Studio, on the *Tools* taskbar, install `GWmodel` package by searching for it under *Install Packages...*.\n\n## 2.0 Installing and Loading the R packages\n\nInstall the following packages:\n\n-   sf\n-   spdep\n-   tmap\n-   tidyverse\n-   knitr\n-   GWmodel (case-sensitive)\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, spdep, tmap, tidyverse, knitr, GWmodel)\n```\n:::\n\n\n## 3.0 Preparing the Data\n\n-   Import Hunan shapefile and parse it into a sf polygon feature object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = \"data/geospatial\", \n                 layer = \"Hunan\") #good practice is to always transform the data into projection\n```\n:::\n\n\n-   Import Hunan_2012.csv file parse it into a tibble data.frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"data/aspatial/Hunan_2012.csv\")\n```\n:::\n\n\n-   Join Hunan and Hunan_2012 data.frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan_sf <- left_join(hunan,hunan2012)%>%\n# always check data when joining (including if there is alpha-case difference)\n    select(1:3, 7, 15, 16, 31, 32) #choose which column to retain for analysis (data tidying)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(hunan_sf, \"data/rds/hunan_sf.rds\")\n# saving intermediate data, save as rds (tibble format)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n## 4.0 Converting to SpatialPolygonDataFrame\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan_sp <- hunan_sf %>%\n  as_Spatial()\n```\n:::\n\n\n## 5.0 Geographically Weighted Summary Statistics with adaptive bandwidth\n\n### 5.1 Determine adative bandwidth\n\nAIC method\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbw_AIC <- bw.gwr(GDPPC ~ 1,\n                 data = hunan_sp,\n                 approach =\"AIC\",\n                 adaptive = TRUE,\n                 kernel = \"bisquare\",\n                 longlat = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAdaptive bandwidth (number of nearest neighbours): 62 AICc value: 1923.156 \nAdaptive bandwidth (number of nearest neighbours): 46 AICc value: 1920.469 \nAdaptive bandwidth (number of nearest neighbours): 36 AICc value: 1917.324 \nAdaptive bandwidth (number of nearest neighbours): 29 AICc value: 1916.661 \nAdaptive bandwidth (number of nearest neighbours): 26 AICc value: 1914.897 \nAdaptive bandwidth (number of nearest neighbours): 22 AICc value: 1914.045 \nAdaptive bandwidth (number of nearest neighbours): 22 AICc value: 1914.045 \n```\n\n\n:::\n\n```{.r .cell-code}\nbw_AIC\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 22\n```\n\n\n:::\n:::\n\n\nCross-validation method\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbw_CV <- bw.gwr(GDPPC ~ 1,\n                 data = hunan_sp,\n                 approach =\"AIC\",\n                 adaptive = TRUE,\n                 kernel = \"bisquare\",\n                 longlat = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAdaptive bandwidth (number of nearest neighbours): 62 AICc value: 1923.156 \nAdaptive bandwidth (number of nearest neighbours): 46 AICc value: 1920.469 \nAdaptive bandwidth (number of nearest neighbours): 36 AICc value: 1917.324 \nAdaptive bandwidth (number of nearest neighbours): 29 AICc value: 1916.661 \nAdaptive bandwidth (number of nearest neighbours): 26 AICc value: 1914.897 \nAdaptive bandwidth (number of nearest neighbours): 22 AICc value: 1914.045 \nAdaptive bandwidth (number of nearest neighbours): 22 AICc value: 1914.045 \n```\n\n\n:::\n\n```{.r .cell-code}\nbw_CV\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 22\n```\n\n\n:::\n:::\n\n\n### 5.2 Determine fixed bandwidth \\*\\*(FIXED)\\*\\* \n\nAIC method\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbw_AIC <- bw.gwr(GDPPC ~ 1,\n                 data = hunan_sp,\n                 approach =\"AIC\",\n                 adaptive = FALSE, #For fixed bandwidth change to false\n                 kernel = \"bisquare\",\n                 longlat = T)\n```\n:::\n\n\nCross-validation method\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbw_CV <- bw.gwr(GDPPC ~ 1,\n                 data = hunan_sp,\n                 approach =\"AIC\",\n                 adaptive = FALSE, #For fixed bandwidth change to false\n                 kernel = \"bisquare\",\n                 longlat = T)\n```\n:::\n\n\n\n### 5.3 Computing Geographically weighted summary statistics\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngwstat <- gwss(data = hunan_sp,\n                vars = \"GDPPC\",\n                bw = bw_AIC, #use the adaptive version\n                kernel = \"bisquare\",\n                adaptive = TRUE,\n                longlat = T)\n```\n:::\n\n\n\n### 5.4 Preparing the output data\n\nCode chunk below is used to extract **SDF** data table from **gwss** object output from `gwss()`. It will be converted into data.frame by using `as.data.frame()`.\n\n::: {.cell}\n\n```{.r .cell-code}\ngwstat_df <- as.data.frame(gwstat$SDF)\n```\n:::\n\n\nNext, `cbind()` is used to append the newly derived data.frame onto *hunan_sf* sf data.frame. \n\n::: {.cell}\n\n```{.r .cell-code}\n hunan_gstat <- cbind(hunan_sf, gwstat_df)\n```\n:::\n\n\n### 5.5 visualising geographically weighted summary statistics\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(hunan_gstat) +\n  tm_fill(\"GDPPC_LM\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Distribution of geographically weighted mean\",\n            main.title.position = \"center\",\n            main.title.size = 1.0,\n            legend.text.size = 0.6,\n            legend.height = 1.50,\n            legend.width = 1.50,\n            frame = TRUE)\n```\n\n::: {.cell-output-display}\n![](ice05_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "ice05_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}